namespace CleanArchitecture.Mediator.Contracts;

/// <summary>
/// Represents a handler responsible for executing a state-changing command 
/// that does not return a meaningful result.
/// </summary>
/// <typeparam name="TCommand">
/// The type of command this handler is designed to process.
/// </typeparam>
/// <remarks>
/// This handler abstraction encapsulates the write-side behavior in a CQRS application.
/// It performs all domain or application logic required to apply the requested state 
/// change, such as creating, updating, or deleting entities.
///
/// This non-generic form is used when the command's outcome does not produce 
/// a response value beyond successful completion. Any failure conditions should be 
/// communicated through exceptions or any mediator-level error-handling pipeline.
/// </remarks>
public interface ICommandHandler<TCommand> where TCommand : ICommand
{
    /// <summary>
    /// Executes the command and applies the corresponding state changes.
    /// </summary>
    /// <param name="command">The command describing the requested operation.</param>
    /// <param name="cancellationToken">
    /// A token that can be used to cancel the operation.
    /// </param>
    Task HandleAsync(TCommand command, CancellationToken cancellationToken = default);
}

/// <summary>
/// Represents a handler responsible for executing a state-changing command 
/// that produces a response value.
/// </summary>
/// <typeparam name="TCommand">
/// The type of command this handler is designed to process.
/// </typeparam>
/// <typeparam name="TResponse">
/// The type of value returned upon successful execution.
/// </typeparam>
/// <remarks>
/// This handler abstraction is used when executing a command yields a result—for example, 
/// a generated identifier, a computed output, or a domain-specific data structure.
///
/// The handler should encapsulate the complete logic necessary to perform the operation, 
/// while mediator pipeline behaviors may wrap the execution to provide concerns such as 
/// validation, authorization, logging, instrumentation, or transactional consistency.
/// </remarks>
public interface ICommandHandler<TCommand, TResponse>
    where TCommand : ICommand<TResponse>
    where TResponse : class
{
    /// <summary>
    /// Executes the command and returns the resulting response value.
    /// </summary>
    /// <param name="command">The command describing the requested operation.</param>
    /// <param name="cancellationToken">
    /// A token that can be used to cancel the operation.
    /// </param>
    /// <returns>
    /// A task that completes with the response generated by the command execution.
    /// </returns>
    Task<TResponse> HandleAsync(TCommand command, CancellationToken cancellationToken = default);
}
